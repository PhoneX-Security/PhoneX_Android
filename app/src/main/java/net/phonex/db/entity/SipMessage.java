package net.phonex.db.entity;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.net.Uri;
import android.os.Parcel;
import android.os.Parcelable;

import net.phonex.core.Constants;
import net.phonex.core.SipUri;
import net.phonex.util.Log;
import net.phonex.util.MiscUtils;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;


/**
 * SipMessage database object, shown in MessageFragment
 */
public class SipMessage implements Parcelable {

    public static final String TAG = "SipMessage";

    public static final String[] FILE_RELATED_PROJECTION = new String[]{
            SipMessage.FIELD_ID, SipMessage.FIELD_FILE_NONCE
    };

    public static final String[] FULL_PROJECTION = new String[]{
            SipMessage.FIELD_ID,
            SipMessage.FIELD_FROM, SipMessage.FIELD_TO,
            SipMessage.FIELD_BODY, SipMessage.FIELD_DATE,
            SipMessage.FIELD_BODY_HASH, SipMessage.FIELD_BODY_DECRYPTED,
            SipMessage.FIELD_SIGNATURE_OK, SipMessage.FIELD_DECRYPTION_STATUS,
            SipMessage.FIELD_SEND_DATE, SipMessage.FIELD_RANDOM_NUM,
            SipMessage.FIELD_MIME_TYPE, SipMessage.FIELD_STATUS,
            SipMessage.FIELD_ERROR_CODE, SipMessage.FIELD_ERROR_TEXT,
            SipMessage.FIELD_FILE_NONCE, SipMessage.FIELD_TYPE,
            SipMessage.FIELD_IS_OUTGOING, SipMessage.FIELD_READ,
            SipMessage.FIELD_RESEND_TIME, SipMessage.FIELD_READ_DATE
    };

    /**
     * Primary key id as it is saved in DB
     *
     * @see Long
     */
    public static final String FIELD_ID = "id";

    /**
     * When working with Cursors, it needs to have 'id' returned in the column named '_id'
     * By design, the identifier is saved in the 'id' column, so DBProvider provides
     * us with a DB layer that returns ROWID as _id when querying messages table.
     *
     * @see Long
     */
    public static final String FIELD_ID_FROM_THREADS_ALIAS = "_id";

    /**
     * From / sender.
     *
     * @see String
     */
    public static final String FIELD_FROM = "sender";
    /**
     * To / receiver.
     *
     * @see String
     */
    public static final String FIELD_TO = "receiver";
    /**
     * Contact of the sip message.
     */
    public static final String FIELD_CONTACT = "contact";
    /**
     * Body / content of the sip message.
     *
     * @see String
     */
    public static final String FIELD_BODY = "body";
    /**
     * Hash of Body / content of the sip message.
     *
     * @see String
     */
    public static final String FIELD_BODY_HASH = "bodyHash";
    /**
     * Decrypted body text (plaintext) part (if applicable)
     *
     * @see String
     */
    public static final String FIELD_BODY_DECRYPTED = "bodyDecrypted";
    /**
     * Flag determining validity of digital signature for this message
     *
     * @see String
     */
    public static final String FIELD_SIGNATURE_OK = "signatureOK";
    /**
     * Flag determining whether decryption of encrypted body part was already done + signature verif.
     *
     * @see String
     */
    public static final String FIELD_DECRYPTION_STATUS = "decryptionStatus";
    /**
     * Random number generated by remote party associated with this message (freshness)
     *
     * @see String
     */
    public static final String FIELD_RANDOM_NUM = "randNum";
    /**
     * Date claimed by user that this message was sent (freshness)
     *
     * @see String
     */
    public static final String FIELD_SEND_DATE = "sendDate";
    public static final String FIELD_IS_OUTGOING = "isOutgoing";

    public static final String FIELD_ERROR_CODE = "msgErrorCode";


    public static final String FIELD_ERROR_TEXT = "msgErrorText";
    public static final String FIELD_MIME_TYPE = "mime_type";
    public static final String FIELD_TYPE = "type";
    /**
     * Reception date of the message.
     *
     * @see Long
     */
    public static final String FIELD_DATE = "date";

    /**
     * Latest pager status.
     *
     * @see Integer
     */
    public static final String FIELD_STATUS = "status";
    public static final String FIELD_READ = "read";
    public static final String FIELD_READ_DATE = "readDate";
    // @Deprecated, this column is removed
    public static final String FIELD_SEND_COUNTER = "sendCounter";

    /**
     * Non canonical sip from
     *
     * @see String
     */
    public static final String FIELD_FROM_FULL = "full_sender";


    /**
     * ID for a corresponding file, null in case of non-file message
     *
     * @see String
     */
    public static final String FIELD_FILE_NONCE = "file_nonce";

    public static final String FIELD_RESEND_TIME = "resendTime";

    public static final String JOIN_FIELD_FILES_COUNT = "files_count";

    public static final String JOIN_FIELD_IMAGES_COUNT = "images_count";

    /**
     * Message mime types
     */
    // standard text message
    public static final String MIME_TEXT = "text/plain";

    // message accompanying file being send
    // contains protocol buffers
    public static final String MIME_FILE = "text/file";
    /**
     * Message received type.
     */
    public static final int MESSAGE_TYPE_INBOX = 1;


    /**
     * Message sent type.
     */
    public static final int MESSAGE_TYPE_SENT = 2;
    /**
     * Failed outgoing message.
     */
    public static final int MESSAGE_TYPE_FAILED = 5;
    /**
     * Message that was already sent but we waiting for ACK
     */
    public static final int MESSAGE_TYPE_PENDING = 6;
    /**
     * Message ready to be sent - stored in Message queue and waiting to be processed.
     */
    public static final int MESSAGE_TYPE_QUEUED = 20;
    public static final int MESSAGE_TYPE_QUEUED_BACKOFF = 21;       // Message is back in the queue (unprocessed), but waiting given timeout before resending
    public static final int MESSAGE_TYPE_ENCRYPT_FAIL = 30;			// Encryption was not successful
    // case of file messages
    public static final int MESSAGE_TYPE_FILE_UPLOADING = 7;		// Upload is in progress.
    public static final int MESSAGE_TYPE_FILE_UPLOADING_FILES = 42;	// Thumbs can be displayed.

    public static final int MESSAGE_TYPE_FILE_UPLOADED = 8;			// File was uploaded successfully.
    public static final int MESSAGE_TYPE_FILE_UPLOAD_FAIL = 14;		// File upload ended with error.
    public static final int MESSAGE_TYPE_FILE_DOWNLOADING = 9;		// Download is in progress.
    public static final int MESSAGE_TYPE_FILE_DOWNLOADING_META = 40;		// Download is in progress.
    public static final int MESSAGE_TYPE_FILE_DOWNLOADED_META = 41;	// File meta data was downloaded successfully (have thumbs).
    public static final int MESSAGE_TYPE_FILE_DOWNLOADED = 10;		// File was downloaded successfully.
    public static final int MESSAGE_TYPE_FILE_DOWNLOAD_FAIL = 15;	// File download ended with error.
    public static final int MESSAGE_TYPE_FILE_READY = 11; 			// user has to decide if he wants to receive a file.
    public static final int MESSAGE_TYPE_FILE_REJECTED = 12; 		// user decided not to receive file.
    public static final int MESSAGE_TYPE_FILE_ERROR_RECEIVING = 13;
    // Content Provider - account

    /**
     * Table for sip message.
     */
    public static final String TABLE_NAME = "messages";
    /**
     * Content type for sip message.
     */
    public static final String MESSAGE_CONTENT_TYPE = Constants.BASE_DIR_TYPE + ".message";
    /**
     * FileItemInfo type for a sip message.
     */
    public static final String MESSAGE_CONTENT_ITEM_TYPE = Constants.BASE_ITEM_TYPE + ".message";
    /**
     * Uri for content provider of sip message
     */
    public static final Uri MESSAGE_URI = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + TABLE_NAME);
    /**
     * Base uri for sip message content provider.<br/>
     * To append with {@link #FIELD_ID}
     *
     * @see ContentUris#appendId(android.net.Uri.Builder, long)
     */
    public static final Uri MESSAGE_ID_URI_BASE = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + TABLE_NAME + "/");
    // Special URIs for insertion/deletion of SipMessage
    public static final Uri MESSAGE_URI_DELETED = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + TABLE_NAME + "_deleted");

    public static final Uri MESSAGE_URI_INSERTED = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + TABLE_NAME + "_inserted");
    /**
     * Table for threads. <br/>
     * It's an alias.
     */
    public static final String THREAD_ALIAS = "thread";

    /**
     * Uri for content provider of threads view.
     */
    public static final Uri THREAD_URI = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + THREAD_ALIAS);
    /**
     * Base uri for thread views.
     */
    public static final Uri THREAD_ID_URI_BASE = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + THREAD_ALIAS + "/");


    /**
     * Uri to retrieve number of unread conversations
     */
    public static final String THREAD_UNREAD_COUNT_ALIAS = "thread_unread_count";
    public static final Uri THREAD_UNREAD_COUNT_URI = Uri.parse(ContentResolver.SCHEME_CONTENT + "://"
            + Constants.AUTHORITY + "/" + THREAD_UNREAD_COUNT_ALIAS);

    /**
     * Status unknown for a message.
     */
    public static final int STATUS_NONE = -1;

    public static final int DECRYPTION_STATUS_NOT_DECRYPTED=0;		// Message is not decrypted yet.

    public static final int DECRYPTION_STATUS_NO_ENCRYPTION=1;		// Message not arrived in ciphertext form.
    public static final int DECRYPTION_STATUS_OK=2;					// Message was decrypted successfully.
    public static final int DECRYPTION_STATUS_DECRYPTION_ERROR=3;	// Error occurred during message decryption (e.g., bad key).
    public static final int ERROR_MISSING_CERT = 100;				// Certificate is missing - message cannot be verified.

    public static final int ERROR_DECRYPT_GENERIC = 101;			// Generic decryption error (e.g., bad format).
    public static final int ERROR_ENCRYPT_GENERIC = 102;			// Generic decryption error (e.g., bad format).
    // SQL Create command for messages table.
    public final static String CREATE_TABLE = "CREATE TABLE IF NOT EXISTS "
            + SipMessage.TABLE_NAME
            + " ("
            + SipMessage.FIELD_ID					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
            + SipMessage.FIELD_FROM				+ " TEXT,"
            + SipMessage.FIELD_TO					+ " TEXT,"
            + SipMessage.FIELD_CONTACT				+ " TEXT,"
            + SipMessage.FIELD_BODY				+ " TEXT,"
            + SipMessage.FIELD_BODY_HASH		+ " TEXT,"
            + SipMessage.FIELD_BODY_DECRYPTED	+ " TEXT, "
            + SipMessage.FIELD_MIME_TYPE			+ " TEXT,"
            + SipMessage.FIELD_ERROR_CODE			+ " TEXT,"
            + SipMessage.FIELD_ERROR_TEXT			+ " TEXT,"
            + SipMessage.FIELD_TYPE				+ " INTEGER,"
            + SipMessage.FIELD_DATE				+ " INTEGER,"
            + SipMessage.FIELD_SEND_DATE		+ " INTEGER,"
            + SipMessage.FIELD_STATUS			+ " INTEGER,"
            + SipMessage.FIELD_IS_OUTGOING		+ " INTEGER,"
            + SipMessage.FIELD_RANDOM_NUM		+ " INTEGER,"
            + SipMessage.FIELD_READ				+ " BOOLEAN,"
            + SipMessage.FIELD_READ_DATE		+ " INTEGER DEFAULT 0,"
            + SipMessage.FIELD_SIGNATURE_OK		+ " INTEGER,"
            + SipMessage.FIELD_DECRYPTION_STATUS	+ " INTEGER,"
            + SipMessage.FIELD_FROM_FULL		+ " TEXT,"
            + SipMessage.FIELD_FILE_NONCE		+ " TEXT,"
            + SipMessage.FIELD_RESEND_TIME		+ " INTEGER DEFAULT 0"
            +");";

    private long id;

    private String from;
    private String fullFrom;
    private String to;
    private String contact;
    private String body;
    private String mimeType;
    private String bodyHash;
    private long date;
    private int type;
    private int status = STATUS_NONE;
    private boolean read = false;
    private long readDate = 0;
    private boolean isOutgoing = false;
    private String bodyDecrypted;
    private boolean signatureOK=false;
    private int decryptionStatus=DECRYPTION_STATUS_NOT_DECRYPTED;
    private int randNum=0;
    private long sendDate=0;
    private int errorCode=0;
    private String errorText="";
    private String fileNonce;
    private long resendTime=0;

    /**
     * Construct from raw datas.
     */
    public SipMessage(String aForm, String aTo, String aContact, String aBody, String aMimeType,
                      long aDate, int aType, String aFullFrom) {
        from = aForm;
        to = aTo;
        contact = aContact;
        body = aBody;
        mimeType = aMimeType;
        date = aDate;
        type = aType;
        fullFrom = aFullFrom;
    }

    public SipMessage(){}

    /**
     * Construct a sip message wrapper from a cursor retrieved with a
     * {@link ContentProvider} query on {@link #TABLE_NAME}.
     * @param c the cursor to unpack
     */
    public SipMessage(Cursor c) {
        ContentValues args = new ContentValues();
        DatabaseUtils.cursorRowToContentValues(c, args);
        createFromContentValue(args);
    }

    /**
     * Pack the object content value to store
     *
     * @return The content value representing the message
     */
    public ContentValues getContentValues() {
        ContentValues cv = new ContentValues();
        cv.put(FIELD_FROM, from);
        cv.put(FIELD_TO, to);
        cv.put(FIELD_CONTACT, contact);
        cv.put(FIELD_BODY_HASH, bodyHash);
        cv.put(FIELD_BODY, body);
        cv.put(FIELD_MIME_TYPE, mimeType);
        cv.put(FIELD_TYPE, type);
        cv.put(FIELD_DATE, date);
        cv.put(FIELD_IS_OUTGOING, isOutgoing ? 1 : 0);
        cv.put(FIELD_STATUS, status);
        cv.put(FIELD_READ, read);
        cv.put(FIELD_READ_DATE, readDate);
        cv.put(FIELD_FROM_FULL, fullFrom);
        cv.put(FIELD_BODY_DECRYPTED, bodyDecrypted);
        cv.put(FIELD_SIGNATURE_OK, signatureOK ? 1 : 0);
        cv.put(FIELD_DECRYPTION_STATUS, decryptionStatus);
        cv.put(FIELD_RANDOM_NUM, randNum);
        cv.put(FIELD_SEND_DATE, sendDate);
        cv.put(FIELD_ERROR_CODE, errorCode);
        cv.put(FIELD_ERROR_TEXT, errorText);
        cv.put(FIELD_FILE_NONCE, fileNonce);
        cv.put(FIELD_RESEND_TIME, resendTime);
        return cv;
    }

    public long getId() {
        return id;
    }

    public boolean isRead() {
        return read;
    }

    public final void createFromContentValue(ContentValues args) {
        Integer tmp_i;
        String tmp_s;
        Long tmp_l;
        Boolean tmp_b;

        tmp_s = args.getAsString(FIELD_FROM);
        if(tmp_s != null) {
            from = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_TO);
        if(tmp_s != null) {
            to = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_CONTACT);
        if(tmp_s != null) {
            contact = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_BODY);
        if(tmp_s != null) {
            body = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_BODY_HASH);
        if(tmp_s != null) {
            bodyHash = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_MIME_TYPE);
        if(tmp_s != null) {
            mimeType = tmp_s;
        }
        tmp_l = args.getAsLong(FIELD_DATE);
        if(tmp_l != null) {
            date = tmp_l;
        }
        tmp_i = args.getAsInteger(FIELD_TYPE);
        if(tmp_i != null) {
            type = tmp_i;
        }
        tmp_i = args.getAsInteger(FIELD_STATUS);
        if(tmp_i != null) {
            status = tmp_i;
        }
        tmp_i = args.getAsInteger(FIELD_READ);
        if(tmp_i != null) {
            read = tmp_i == 1;
        }
        tmp_l = args.getAsLong(FIELD_READ_DATE);
        if(tmp_l != null) {
            readDate = tmp_l;
        }
        tmp_s = args.getAsString(FIELD_FROM_FULL);
        if(tmp_s != null) {
            fullFrom = tmp_s;
        }
        tmp_s = args.getAsString(FIELD_BODY_DECRYPTED);
        if(tmp_s != null) {
            bodyDecrypted = tmp_s;

        }
        tmp_i = args.getAsInteger(FIELD_SIGNATURE_OK);
        if(tmp_i != null) {
            signatureOK = tmp_i == 1;
        }
        tmp_i = args.getAsInteger(FIELD_DECRYPTION_STATUS);
        if(tmp_i != null) {
            decryptionStatus = tmp_i;
        }
        tmp_i = args.getAsInteger(FIELD_RANDOM_NUM);
        if(tmp_i != null) {
            randNum = tmp_i;
        }
        tmp_l = args.getAsLong(FIELD_SEND_DATE);
        if(tmp_l != null) {
            sendDate = tmp_l;
        }
        tmp_i = args.getAsInteger(FIELD_ERROR_CODE);
        if(tmp_i != null) {
            errorCode = tmp_i;
        }
        tmp_s = args.getAsString(FIELD_ERROR_TEXT);
        if(tmp_s != null) {
            errorText = tmp_s;
        }
        tmp_l = args.getAsLong(FIELD_ID_FROM_THREADS_ALIAS);
        if(tmp_l != null) {
            id= tmp_l;
        }
        tmp_l = args.getAsLong(FIELD_ID);
        if(tmp_l != null) {
            id= tmp_l;
        }
        tmp_i = args.getAsInteger(FIELD_IS_OUTGOING);
        if(tmp_i != null) {
            isOutgoing = tmp_i == 1;
        }
        tmp_s = args.getAsString(FIELD_FILE_NONCE);
        if(tmp_s != null) {
            fileNonce = tmp_s;
        }
        tmp_l = args.getAsLong(FIELD_RESEND_TIME);
        if(tmp_l != null) {
            resendTime= tmp_l;
        }
    }
    public String getFrom() {
        return from;
    }

    public String getBody() {
        return body;
    }

    public String getTo() {
        return to;
    }

    public void setRead(boolean b) {
        read = b;

    }

    public String getDisplayName() {
        return SipUri.getDisplayedSimpleContact(fullFrom);
    }

    public String getRemoteNumber() {
        if (isOutgoing) {
            return to;
        }else {
            return from;
        }
    }

    /**
     * Returns real plaintext body of this message.
     * @return
     */
    public String getPlainBody(){
        if (isOutgoing){
            return getBody();
        } else if (decryptionStatus==DECRYPTION_STATUS_OK) {
            return getBodyDecrypted();
        } else {
            return null;
        }
    }

    public void setOutgoing(boolean isOutgoing) {
        this.isOutgoing = isOutgoing;
    }

    public String getBodyContent() {
        return body;
    }

    public boolean isOutgoing() {
        return isOutgoing;
    }

    public long getDate() {
        return date;
    }

    /**
     * Get the complete remote contact from which the message comes.<br/>
     * This includes display name.
     *
     * @return the sip uri of remote contact as announced when sending this message.
     */
    public String getFullFrom() {
        return fullFrom;
    }

    public int getType() {
        return type;
    }

    /**
     * Get the mime type of the message.
     *
     * @return the message mime type sent by remote party.
     */
    public String getMimeType() {
        return mimeType;
    }

    public String getBodyHash() {
        return bodyHash;
    }

    public void setBodyHash(String bodyHash) {
        this.bodyHash = bodyHash;
    }

    public String getBodyDecrypted() {
        return bodyDecrypted;
    }

    public void setBodyDecrypted(String bodyDecrypted) {
        this.bodyDecrypted = bodyDecrypted;
    }

    public boolean isSignatureOK() {
        return signatureOK;
    }

    public void setSignatureOK(boolean signatureOK) {
        this.signatureOK = signatureOK;
    }

    public int getDecryptionStatus() {
        return decryptionStatus;
    }

    public void setDecryptionStatus(int decryptionStatus) {
        this.decryptionStatus = decryptionStatus;
    }

    public int getRandNum() {
        return randNum;
    }

    public void setRandNum(int randNum) {
        this.randNum = randNum;
    }

    public long getSendDate() {
        return sendDate;
    }

    public void setSendDate(long sendDate) {
        this.sendDate = sendDate;
    }

    public int getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(int errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorText() {
        return errorText;
    }

    public void setErrorText(String errorText) {
        this.errorText = errorText;
    }

    public String getFileNonce() {
        return fileNonce;
    }

    public void setFileNonce(String fileNonce) {
        this.fileNonce = fileNonce;
    }

    public long getResendTime() {
        return resendTime;
    }

    public long getReadDate() {
        return readDate;
    }

    public void setId(long id) {
        this.id = id;
    }

    public boolean isFileType(){
        return mimeType.equals(SipMessage.MIME_FILE)
                || mimeType.equals(Constants.SIP_SECURE_FILE_NOTIFY_MIME);
    }

    /**
     * Loads message by ID.
     * Uses file related projection.
     *
     * @param cr
     * @param messageId
     * @return
     */
    public static SipMessage getById(ContentResolver cr, long messageId){
        return getById(cr, messageId, SipMessage.FILE_RELATED_PROJECTION);
    }

    /**
     * Loads message by ID.
     * @param cr
     * @param messageId
     * @return
     */
    public static SipMessage getById(ContentResolver cr, long messageId, String[] projection){
        Cursor c = cr.query(
                SipMessage.MESSAGE_URI,
                projection,
                SipMessage.FIELD_ID + "=?",
                new String[] { String.valueOf(messageId)},
                null);

        if (c != null) {
            try {
                if (c.moveToFirst()){
                    SipMessage msg = new SipMessage(c);
                    return msg;
                }
            } catch (Exception e) {
                Log.e(TAG, "Error while getting message ID", e);
                return null;
            } finally {
                c.close();
            }
        }

        return null;
    }

    /**
     * Deletes message by given message id.
     * @param cr
     * @param messageId
     * @return
     */
    public static int deleteById(ContentResolver cr, long messageId){
        try {
            return cr.delete(MESSAGE_URI, SipMessage.FIELD_ID + "=?", new String[] {String.valueOf(messageId)} );
        } catch (Exception e){
            Log.ef(TAG, e, "Exception: Cannot remove message id=%d", messageId);
        }

        return -1;
    }

    /**
     * set SipMessage Type property
     * @param cr
     * @param messageId
     * @param messageType
     */
    public static void setMessageType(ContentResolver cr, long messageId, int messageType){
        ContentValues args = new ContentValues();
        args.put(SipMessage.FIELD_TYPE, messageType);
        int rowsUpdated = cr.update(SipMessage.MESSAGE_URI, args,
                SipMessage.FIELD_ID + "=?",
                new String[] { String.valueOf(messageId) });
        if (rowsUpdated<=0){
            Log.ef(TAG, "Msg with ID=[%s] was not found in DB, cannot be set to [%s]", messageId, messageType);
        }
        Log.df(TAG, "Updated msg [id=%s] property FIELD_TYPE to [%s]", String.valueOf(messageId), messageType);
    }

    /**
     * Sets message type, error code and error text.
     *
     * @param cr
     * @param msgid
     * @param msgtype
     * @param errCode
     * @param errText
     * @return
     */
    public static int setMessageError(ContentResolver cr, long msgid, int msgtype, int errCode, String errText){
        try {
            ContentValues args = new ContentValues();
            args.put(SipMessage.FIELD_TYPE, msgtype);
            args.put(SipMessage.FIELD_ERROR_CODE, errCode);
            args.put(SipMessage.FIELD_ERROR_TEXT, errText);
            return cr.update(
                    SipMessage.MESSAGE_URI,
                    args,
                    SipMessage.FIELD_ID + "=?",
                    new String[] { Long.toString(msgid) });
        } catch (Exception e){
            Log.e(TAG, "Cannot update message - store error code.", e);
        }

        return -1;
    }

    /**
     * Updates message with given ID with provided content values.
     *
     * @param cr
     * @param msgid
     * @param cv
     * @return
     */
    public static int updateMessage(ContentResolver cr, long msgid, ContentValues cv){
        return cr.update(SipMessage.MESSAGE_URI, cv,
                SipMessage.FIELD_ID + "=?",
                new String[] { String.valueOf(msgid) });
    }

    /**
     * Returns collection of message IDs related to the particular user name.
     * @param username
     * @param cr
     * @return
     */
    public static Collection<Long> getAllFileMsgIdsRelatedToUser(String username, ContentResolver cr) {
        LinkedList<Long> acc = new LinkedList<Long>();
        Cursor cMerged = null;

        try {
            cMerged = cr.query(SipMessage.MESSAGE_URI,
                    new String[] {SipMessage.FIELD_ID},
                    String.format("(%s=1 AND %s=? AND %s=?) OR (%s=0 AND %s=? AND %s=?)",
                            SipMessage.FIELD_IS_OUTGOING,
                            SipMessage.FIELD_TO,
                            SipMessage.FIELD_MIME_TYPE,
                            SipMessage.FIELD_IS_OUTGOING,
                            SipMessage.FIELD_FROM,
                            SipMessage.FIELD_MIME_TYPE),
                    new String[] {username, SipMessage.MIME_FILE, username, SipMessage.MIME_FILE},
                    null);

            if (cMerged == null){
                return new ArrayList<>();
            }

            while(cMerged.moveToNext()){
                Long cId = cMerged.getLong(0);
                acc.add(cId);
            }

        } catch(Throwable e){
            Log.e(TAG, "Error during loading messages, exception=%@", e);
        } finally {
            MiscUtils.closeCursorSilently(cMerged);;
        }

        return acc;
    }

    public static int getUnreadConversationsCount(ContentResolver cr){
        try {
            Cursor countCursor = cr.query(THREAD_UNREAD_COUNT_URI, null, null, null, null);
            if (countCursor == null){
                Log.wf(TAG, "getUnreadConversationsCount; Cursor is null!");
                return 0;
            }
            int count = countCursor.getCount();
            MiscUtils.closeCursorSilently(countCursor);
            Log.vf(TAG, "getUnreadConversationsCount: count=%d", count);
            return count;
        } catch (Exception ex) {
            Log.e(TAG, "getUnreadConversationsCount; unexpected error", ex);
            return 0;
        }
    }

    /**
     * return randNum or establish a new one for SipMessage
     * @param cr
     * @return
     */
    public int getOrEstablishRandNum(ContentResolver cr, SecureRandom srand){
        if (randNum != 0){
            return randNum;
        } else {
            randNum = srand.nextInt();
            ContentValues cv = new ContentValues();
            cv.put(FIELD_RANDOM_NUM, randNum);
            updateMessage(cr, getId(), cv);
            return randNum;
        }
    }

    public int getOrEstablishRandNum(ContentResolver cr){
        if (randNum!=0){
            return randNum;
        } else {
            return getOrEstablishRandNum(cr, new SecureRandom());
        }
    }

    public boolean canBeForwarded(){
        // Text messages can always be forwarded
        if (!isFileType()){
            return true;
        }

        switch (type){
            // In some states, we do not have files ready to be forwarded
            case MESSAGE_TYPE_FILE_UPLOAD_FAIL:
            case MESSAGE_TYPE_FILE_UPLOADING:
            case MESSAGE_TYPE_FILE_DOWNLOADING:
            case MESSAGE_TYPE_FILE_DOWNLOADING_META:
            case MESSAGE_TYPE_FILE_DOWNLOADED_META:
            case MESSAGE_TYPE_FILE_DOWNLOAD_FAIL:
            case MESSAGE_TYPE_FILE_READY:
            case MESSAGE_TYPE_FILE_REJECTED:
            case MESSAGE_TYPE_FILE_ERROR_RECEIVING:
                return false;
            default:
                return true;
        }
    }

    @Override
    public String toString() {
        return "SipMessage{" +
                "id=" + id +
                ", from='" + from + '\'' +
                ", fullFrom='" + fullFrom + '\'' +
                ", to='" + to + '\'' +
                ", contact='" + contact + '\'' +
                ", body='" + body + '\'' +
                ", mimeType='" + mimeType + '\'' +
                ", bodyHash='" + bodyHash + '\'' +
                ", date=" + date +
                ", type=" + type +
                ", status=" + status +
                ", read=" + read +
                ", readDate=" + readDate +
                ", isOutgoing=" + isOutgoing +
                ", bodyDecrypted='" + bodyDecrypted + '\'' +
                ", signatureOK=" + signatureOK +
                ", decryptionStatus=" + decryptionStatus +
                ", randNum=" + randNum +
                ", sendDate=" + sendDate +
                ", errorCode=" + errorCode +
                ", errorText='" + errorText + '\'' +
                ", fileNonce='" + fileNonce + '\'' +
                ", resendTime=" + resendTime +
                '}';
    }

    protected SipMessage(Parcel in) {
        id = in.readLong();
        from = in.readString();
        fullFrom = in.readString();
        to = in.readString();
        contact = in.readString();
        body = in.readString();
        mimeType = in.readString();
        bodyHash = in.readString();
        date = in.readLong();
        type = in.readInt();
        status = in.readInt();
        read = in.readByte() != 0x00;
        readDate = in.readLong();
        isOutgoing = in.readByte() != 0x00;
        bodyDecrypted = in.readString();
        signatureOK = in.readByte() != 0x00;
        decryptionStatus = in.readInt();
        randNum = in.readInt();
        sendDate = in.readLong();
        errorCode = in.readInt();
        errorText = in.readString();
        fileNonce = in.readString();
        resendTime = in.readLong();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeLong(id);
        dest.writeString(from);
        dest.writeString(fullFrom);
        dest.writeString(to);
        dest.writeString(contact);
        dest.writeString(body);
        dest.writeString(mimeType);
        dest.writeString(bodyHash);
        dest.writeLong(date);
        dest.writeInt(type);
        dest.writeInt(status);
        dest.writeByte((byte) (read ? 0x01 : 0x00));
        dest.writeLong(readDate);
        dest.writeByte((byte) (isOutgoing ? 0x01 : 0x00));
        dest.writeString(bodyDecrypted);
        dest.writeByte((byte) (signatureOK ? 0x01 : 0x00));
        dest.writeInt(decryptionStatus);
        dest.writeInt(randNum);
        dest.writeLong(sendDate);
        dest.writeInt(errorCode);
        dest.writeString(errorText);
        dest.writeString(fileNonce);
        dest.writeLong(resendTime);
    }

    @SuppressWarnings("unused")
    public static final Parcelable.Creator<SipMessage> CREATOR = new Parcelable.Creator<SipMessage>() {
        @Override
        public SipMessage createFromParcel(Parcel in) {
            return new SipMessage(in);
        }

        @Override
        public SipMessage[] newArray(int size) {
            return new SipMessage[size];
        }
    };
}